<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Defining tasks &mdash; Fabric-docs-cn 1.8 documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.8',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="Fabric-docs-cn 1.8 documentation" href="../index.html" />
    <link rel="next" title="Console Output Utilities" href="../api/contrib/console.html" />
    <link rel="prev" title="SSH behavior" href="ssh.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../api/contrib/console.html" title="Console Output Utilities"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="ssh.html" title="SSH behavior"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Fabric-docs-cn 1.8 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="defining-tasks">
<h1>Defining tasks<a class="headerlink" href="#defining-tasks" title="Permalink to this headline">¶</a></h1>
<p>As of Fabric 1.1, there are two distinct methods you may use in order to define
which objects in your fabfile show up as tasks:</p>
<ul class="simple">
<li>The &#8220;new&#8221; method starting in 1.1 considers instances of <cite>~fabric.tasks.Task</cite>
or its subclasses, and also descends into imported modules to allow building
nested namespaces.</li>
<li>The &#8220;classic&#8221; method from 1.0 and earlier considers all public callable
objects (functions, classes etc) and only considers the objects in the
fabfile itself with no recursing into imported module.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">These two methods are <strong>mutually exclusive</strong>: if Fabric finds <em>any</em>
new-style task objects in your fabfile or in modules it imports, it will
assume you&#8217;ve committed to this method of task declaration and won&#8217;t
consider any non-<cite>~fabric.tasks.Task</cite> callables. If <em>no</em> new-style tasks
are found, it reverts to the classic behavior.</p>
</div>
<p>The rest of this document explores these two methods in detail.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">To see exactly what tasks in your fabfile may be executed via <tt class="docutils literal"><span class="pre">fab</span></tt>, use
<a class="reference internal" href="fab.html#cmdoption-l"><em class="xref std std-option">fab --list</em></a>.</p>
</div>
<div class="section" id="new-style-tasks">
<span id="id1"></span><h2>New-style tasks<a class="headerlink" href="#new-style-tasks" title="Permalink to this headline">¶</a></h2>
<p>Fabric 1.1 introduced the <cite>~fabric.tasks.Task</cite> class to facilitate new features
and enable some programming best practices, specifically:</p>
<ul class="simple">
<li><strong>Object-oriented tasks</strong>. Inheritance and all that comes with it can make
for much more sensible code reuse than passing around simple function
objects.  The classic style of task declaration didn&#8217;t entirely rule this
out, but it also didn&#8217;t make it terribly easy.</li>
<li><strong>Namespaces</strong>. Having an explicit method of declaring tasks makes it easier
to set up recursive namespaces without e.g. polluting your task list with the
contents of Python&#8217;s <tt class="docutils literal"><span class="pre">os</span></tt> module (which would show up as valid &#8220;tasks&#8221;
under the classic methodology.)</li>
</ul>
<p>With the introduction of <cite>~fabric.tasks.Task</cite>, there are two ways to set up new
tasks:</p>
<ul class="simple">
<li>Decorate a regular module level function with <cite>&#64;task
&lt;fabric.decorators.task&gt;</cite>, which transparently wraps the function in a
<cite>~fabric.tasks.Task</cite> subclass.  The function name will be used as the task
name when invoking.</li>
<li>Subclass <cite>~fabric.tasks.Task</cite> (<cite>~fabric.tasks.Task</cite> itself is intended to be
abstract), define a <tt class="docutils literal"><span class="pre">run</span></tt> method, and instantiate your subclass at module
level. Instances&#8217; <tt class="docutils literal"><span class="pre">name</span></tt> attributes are used as the task name; if omitted
the instance&#8217;s variable name will be used instead.</li>
</ul>
<p>Use of new-style tasks also allows you to set up <a class="reference internal" href="#namespaces"><em>namespaces</em></a>.</p>
<div class="section" id="the-task-decorator">
<span id="task-decorator"></span><h3>The <tt class="docutils literal"><span class="pre">&#64;task</span></tt> decorator<a class="headerlink" href="#the-task-decorator" title="Permalink to this headline">¶</a></h3>
<p>The quickest way to make use of new-style task features is to wrap basic task functions with <cite>&#64;task &lt;fabric.decorators.task&gt;</cite>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">fabric.api</span> <span class="kn">import</span> <span class="n">task</span><span class="p">,</span> <span class="n">run</span>

<span class="nd">@task</span>
<span class="k">def</span> <span class="nf">mytask</span><span class="p">():</span>
    <span class="n">run</span><span class="p">(</span><span class="s">&quot;a command&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>When this decorator is used, it signals to Fabric that <em>only</em> functions wrapped in the decorator are to be loaded up as valid tasks. (When not present, <a class="reference internal" href="#classic-tasks"><em>classic-style task</em></a> behavior kicks in.)</p>
<div class="section" id="arguments">
<span id="task-decorator-arguments"></span><h4>Arguments<a class="headerlink" href="#arguments" title="Permalink to this headline">¶</a></h4>
<p><cite>&#64;task &lt;fabric.decorators.task&gt;</cite> may also be called with arguments to
customize its behavior. Any arguments not documented below are passed into the
constructor of the <tt class="docutils literal"><span class="pre">task_class</span></tt> being used, with the function itself as the
first argument (see <a class="reference internal" href="#task-decorator-and-classes"><em>Using custom subclasses with &#64;task</em></a> for details.)</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">task_class</span></tt>: The <cite>~fabric.tasks.Task</cite> subclass used to wrap the decorated
function. Defaults to <cite>~fabric.tasks.WrappedCallableTask</cite>.</li>
<li><tt class="docutils literal"><span class="pre">aliases</span></tt>: An iterable of string names which will be used as aliases for
the wrapped function. See <a class="reference internal" href="#task-aliases"><em>Aliases</em></a> for details.</li>
<li><tt class="docutils literal"><span class="pre">alias</span></tt>: Like <tt class="docutils literal"><span class="pre">aliases</span></tt> but taking a single string argument instead of an
iterable. If both <tt class="docutils literal"><span class="pre">alias</span></tt> and <tt class="docutils literal"><span class="pre">aliases</span></tt> are specified, <tt class="docutils literal"><span class="pre">aliases</span></tt> will
take precedence.</li>
<li><tt class="docutils literal"><span class="pre">default</span></tt>: A boolean value determining whether the decorated task also
stands in for its containing module as a task name. See <a class="reference internal" href="#default-tasks"><em>Default tasks</em></a>.</li>
<li><tt class="docutils literal"><span class="pre">name</span></tt>: A string setting the name this task appears as to the command-line
interface. Useful for task names that would otherwise shadow Python builtins
(which is technically legal but frowned upon and bug-prone.)</li>
</ul>
</div>
<div class="section" id="aliases">
<span id="task-aliases"></span><h4>Aliases<a class="headerlink" href="#aliases" title="Permalink to this headline">¶</a></h4>
<p>Here&#8217;s a quick example of using the <tt class="docutils literal"><span class="pre">alias</span></tt> keyword argument to facilitate
use of both a longer human-readable task name, and a shorter name which is
quicker to type:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">fabric.api</span> <span class="kn">import</span> <span class="n">task</span>

<span class="nd">@task</span><span class="p">(</span><span class="n">alias</span><span class="o">=</span><span class="s">&#39;dwm&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">deploy_with_migrations</span><span class="p">():</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>Calling <a class="reference internal" href="fab.html#cmdoption-l"><em class="xref std std-option">--list</em></a> on this fabfile would show both the original
<tt class="docutils literal"><span class="pre">deploy_with_migrations</span></tt> and its alias <tt class="docutils literal"><span class="pre">dwm</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre>$ fab --list
Available commands:

    deploy_with_migrations
    dwm
</pre></div>
</div>
<p>When more than one alias for the same function is needed, simply swap in the
<tt class="docutils literal"><span class="pre">aliases</span></tt> kwarg, which takes an iterable of strings instead of a single
string.</p>
</div>
<div class="section" id="default-tasks">
<span id="id2"></span><h4>Default tasks<a class="headerlink" href="#default-tasks" title="Permalink to this headline">¶</a></h4>
<p>In a similar manner to <a class="reference internal" href="#task-aliases"><em>aliases</em></a>, it&#8217;s sometimes useful to
designate a given task within a module as the &#8220;default&#8221; task, which may be
called by referencing <em>just</em> the module name. This can save typing and/or
allow for neater organization when there&#8217;s a single &#8220;main&#8221; task and a number
of related tasks or subroutines.</p>
<p>For example, a <tt class="docutils literal"><span class="pre">deploy</span></tt> submodule might contain tasks for provisioning new
servers, pushing code, migrating databases, and so forth &#8211; but it&#8217;d be very
convenient to highlight a task as the default &#8220;just deploy&#8221; action. Such a
<tt class="docutils literal"><span class="pre">deploy.py</span></tt> module might look like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">fabric.api</span> <span class="kn">import</span> <span class="n">task</span>

<span class="nd">@task</span>
<span class="k">def</span> <span class="nf">migrate</span><span class="p">():</span>
    <span class="k">pass</span>

<span class="nd">@task</span>
<span class="k">def</span> <span class="nf">push</span><span class="p">():</span>
    <span class="k">pass</span>

<span class="nd">@task</span>
<span class="k">def</span> <span class="nf">provision</span><span class="p">():</span>
    <span class="k">pass</span>

<span class="nd">@task</span>
<span class="k">def</span> <span class="nf">full_deploy</span><span class="p">():</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">provisioned</span><span class="p">:</span>
        <span class="n">provision</span><span class="p">()</span>
    <span class="n">push</span><span class="p">()</span>
    <span class="n">migrate</span><span class="p">()</span>
</pre></div>
</div>
<p>With the following task list (assuming a simple top level <tt class="docutils literal"><span class="pre">fabfile.py</span></tt> that just imports <tt class="docutils literal"><span class="pre">deploy</span></tt>):</p>
<div class="highlight-python"><div class="highlight"><pre>$ fab --list
Available commands:

    deploy.full_deploy
    deploy.migrate
    deploy.provision
    deploy.push
</pre></div>
</div>
<p>Calling <tt class="docutils literal"><span class="pre">deploy.full_deploy</span></tt> on every deploy could get kind of old, or somebody new to the team might not be sure if that&#8217;s really the right task to run.</p>
<p>Using the <tt class="docutils literal"><span class="pre">default</span></tt> kwarg to <cite>&#64;task &lt;fabric.decorators.task&gt;</cite>, we can tag
e.g. <tt class="docutils literal"><span class="pre">full_deploy</span></tt> as the default task:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@task</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">full_deploy</span><span class="p">():</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>Doing so updates the task list like so:</p>
<div class="highlight-python"><div class="highlight"><pre>$ fab --list
Available commands:

    deploy
    deploy.full_deploy
    deploy.migrate
    deploy.provision
    deploy.push
</pre></div>
</div>
<p>Note that <tt class="docutils literal"><span class="pre">full_deploy</span></tt> still exists as its own explicit task &#8211; but now
<tt class="docutils literal"><span class="pre">deploy</span></tt> shows up as a sort of top level alias for <tt class="docutils literal"><span class="pre">full_deploy</span></tt>.</p>
<p>If multiple tasks within a module have <tt class="docutils literal"><span class="pre">default=True</span></tt> set, the last one to
be loaded (typically the one lowest down in the file) will take precedence.</p>
</div>
<div class="section" id="top-level-default-tasks">
<h4>Top-level default tasks<a class="headerlink" href="#top-level-default-tasks" title="Permalink to this headline">¶</a></h4>
<p>Using <tt class="docutils literal"><span class="pre">&#64;task(default=True)</span></tt> in the top level fabfile will cause the denoted
task to execute when a user invokes <tt class="docutils literal"><span class="pre">fab</span></tt> without any task names (similar to
e.g. <tt class="docutils literal"><span class="pre">make</span></tt>.) When using this shortcut, it is not possible to specify
arguments to the task itself &#8211; use a regular invocation of the task if this
is necessary.</p>
</div>
</div>
<div class="section" id="task-subclasses">
<span id="id3"></span><h3><tt class="docutils literal"><span class="pre">Task</span></tt> subclasses<a class="headerlink" href="#task-subclasses" title="Permalink to this headline">¶</a></h3>
<p>If you&#8217;re used to <a class="reference internal" href="#classic-tasks"><em>classic-style tasks</em></a>, an easy way to
think about <cite>~fabric.tasks.Task</cite> subclasses is that their <tt class="docutils literal"><span class="pre">run</span></tt> method is
directly equivalent to a classic task; its arguments are the task arguments
(other than <tt class="docutils literal"><span class="pre">self</span></tt>) and its body is what gets executed.</p>
<p>For example, this new-style task:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MyTask</span><span class="p">(</span><span class="n">Task</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;deploy&quot;</span>
    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">environment</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="s">&quot;whatever.com&quot;</span><span class="p">):</span>
        <span class="n">run</span><span class="p">(</span><span class="s">&quot;git clone foo&quot;</span><span class="p">)</span>
        <span class="n">sudo</span><span class="p">(</span><span class="s">&quot;service apache2 restart&quot;</span><span class="p">)</span>

<span class="n">instance</span> <span class="o">=</span> <span class="n">MyTask</span><span class="p">()</span>
</pre></div>
</div>
<p>is exactly equivalent to this function-based task:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@task</span>
<span class="k">def</span> <span class="nf">deploy</span><span class="p">(</span><span class="n">environment</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="s">&quot;whatever.com&quot;</span><span class="p">):</span>
    <span class="n">run</span><span class="p">(</span><span class="s">&quot;git clone foo&quot;</span><span class="p">)</span>
    <span class="n">sudo</span><span class="p">(</span><span class="s">&quot;service apache2 restart&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Note how we had to instantiate an instance of our class; that&#8217;s simply normal
Python object-oriented programming at work. While it&#8217;s a small bit of
boilerplate right now &#8211; for example, Fabric doesn&#8217;t care about the name you
give the instantiation, only the instance&#8217;s <tt class="docutils literal"><span class="pre">name</span></tt> attribute &#8211; it&#8217;s well
worth the benefit of having the power of classes available.</p>
<p>We plan to extend the API in the future to make this experience a bit smoother.</p>
<div class="section" id="using-custom-subclasses-with-task">
<span id="task-decorator-and-classes"></span><h4>Using custom subclasses with <tt class="docutils literal"><span class="pre">&#64;task</span></tt><a class="headerlink" href="#using-custom-subclasses-with-task" title="Permalink to this headline">¶</a></h4>
<p>It&#8217;s possible to marry custom <cite>~fabric.tasks.Task</cite> subclasses with <cite>&#64;task
&lt;fabric.decorators.task&gt;</cite>. This may be useful in cases where your core
execution logic doesn&#8217;t do anything class/object-specific, but you want to
take advantage of class metaprogramming or similar techniques.</p>
<p>Specifically, any <cite>~fabric.tasks.Task</cite> subclass which is designed to take in a
callable as its first constructor argument (as the built-in
<cite>~fabric.tasks.WrappedCallableTask</cite> does) may be specified as the
<tt class="docutils literal"><span class="pre">task_class</span></tt> argument to <cite>&#64;task &lt;fabric.decorators.task&gt;</cite>.</p>
<p>Fabric will automatically instantiate a copy of the given class, passing in
the wrapped function as the first argument. All other args/kwargs given to the
decorator (besides the &#8220;special&#8221; arguments documented in
<a class="reference internal" href="#task-decorator-arguments"><em>Arguments</em></a>) are added afterwards.</p>
<p>Here&#8217;s a brief and somewhat contrived example to make this obvious:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">fabric.api</span> <span class="kn">import</span> <span class="n">task</span>
<span class="kn">from</span> <span class="nn">fabric.tasks</span> <span class="kn">import</span> <span class="n">Task</span>

<span class="k">class</span> <span class="nc">CustomTask</span><span class="p">(</span><span class="n">Task</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">myarg</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">CustomTask</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">myarg</span> <span class="o">=</span> <span class="n">myarg</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="nd">@task</span><span class="p">(</span><span class="n">task_class</span><span class="o">=</span><span class="n">CustomTask</span><span class="p">,</span> <span class="n">myarg</span><span class="o">=</span><span class="s">&#39;value&#39;</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="s">&#39;at&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">actual_task</span><span class="p">():</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>When this fabfile is loaded, a copy of <tt class="docutils literal"><span class="pre">CustomTask</span></tt> is instantiated, effectively calling:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">task_obj</span> <span class="o">=</span> <span class="n">CustomTask</span><span class="p">(</span><span class="n">actual_task</span><span class="p">,</span> <span class="n">myarg</span><span class="o">=</span><span class="s">&#39;value&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Note how the <tt class="docutils literal"><span class="pre">alias</span></tt> kwarg is stripped out by the decorator itself and never
reaches the class instantiation; this is identical in function to how
<a class="reference internal" href="fab.html#task-arguments"><em>command-line task arguments</em></a> work.</p>
</div>
</div>
<div class="section" id="namespaces">
<span id="id4"></span><h3>Namespaces<a class="headerlink" href="#namespaces" title="Permalink to this headline">¶</a></h3>
<p>With <a class="reference internal" href="#classic-tasks"><em>classic tasks</em></a>, fabfiles were limited to a single,
flat set of task names with no real way to organize them.  In Fabric 1.1 and
newer, if you declare tasks the new way (via <cite>&#64;task &lt;fabric.decorators.task&gt;</cite>
or your own <cite>~fabric.tasks.Task</cite> subclass instances) you may take advantage
of <strong>namespacing</strong>:</p>
<ul class="simple">
<li>Any module objects imported into your fabfile will be recursed into, looking
for additional task objects.</li>
<li>Within submodules, you may control which objects are &#8220;exported&#8221; by using the
standard Python <tt class="docutils literal"><span class="pre">__all__</span></tt> module-level variable name (thought they should
still be valid new-style task objects.)</li>
<li>These tasks will be given new dotted-notation names based on the modules they
came from, similar to Python&#8217;s own import syntax.</li>
</ul>
<p>Let&#8217;s build up a fabfile package from simple to complex and see how this works.</p>
<div class="section" id="basic">
<h4>Basic<a class="headerlink" href="#basic" title="Permalink to this headline">¶</a></h4>
<p>We start with a single <cite>__init__.py</cite> containing a few tasks (the Fabric API
import omitted for brevity):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@task</span>
<span class="k">def</span> <span class="nf">deploy</span><span class="p">():</span>
    <span class="o">...</span>

<span class="nd">@task</span>
<span class="k">def</span> <span class="nf">compress</span><span class="p">():</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>The output of <tt class="docutils literal"><span class="pre">fab</span> <span class="pre">--list</span></tt> would look something like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">deploy</span>
<span class="n">compress</span>
</pre></div>
</div>
<p>There&#8217;s just one namespace here: the &#8220;root&#8221; or global namespace. Looks simple
now, but in a real-world fabfile with dozens of tasks, it can get difficult to
manage.</p>
</div>
<div class="section" id="importing-a-submodule">
<h4>Importing a submodule<a class="headerlink" href="#importing-a-submodule" title="Permalink to this headline">¶</a></h4>
<p>As mentioned above, Fabric will examine any imported module objects for tasks,
regardless of where that module exists on your Python import path.  For now we
just want to include our own, &#8220;nearby&#8221; tasks, so we&#8217;ll make a new submodule in
our package for dealing with, say, load balancers &#8211; <tt class="docutils literal"><span class="pre">lb.py</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@task</span>
<span class="k">def</span> <span class="nf">add_backend</span><span class="p">():</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>And we&#8217;ll add this to the top of <tt class="docutils literal"><span class="pre">__init__.py</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">lb</span>
</pre></div>
</div>
<p>Now <tt class="docutils literal"><span class="pre">fab</span> <span class="pre">--list</span></tt> shows us:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">deploy</span>
<span class="n">compress</span>
<span class="n">lb</span><span class="o">.</span><span class="n">add_backend</span>
</pre></div>
</div>
<p>Again, with only one task in its own submodule, it looks kind of silly, but the
benefits should be pretty obvious.</p>
</div>
<div class="section" id="going-deeper">
<h4>Going deeper<a class="headerlink" href="#going-deeper" title="Permalink to this headline">¶</a></h4>
<p>Namespacing isn&#8217;t limited to just one level. Let&#8217;s say we had a larger setup
and wanted a namespace for database related tasks, with additional
differentiation inside that. We make a sub-package named <tt class="docutils literal"><span class="pre">db/</span></tt> and inside it,
a <tt class="docutils literal"><span class="pre">migrations.py</span></tt> module:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="nd">@task</span>
<span class="k">def</span> <span class="nf">list</span><span class="p">():</span>
    <span class="o">...</span>

<span class="nd">@task</span>
<span class="k">def</span> <span class="nf">run</span><span class="p">():</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>We need to make sure that this module is visible to anybody importing <tt class="docutils literal"><span class="pre">db</span></tt>,
so we add it to the sub-package&#8217;s <tt class="docutils literal"><span class="pre">__init__.py</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">migrations</span>
</pre></div>
</div>
<p>As a final step, we import the sub-package into our root-level <tt class="docutils literal"><span class="pre">__init__.py</span></tt>,
so now its first few lines look like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">lb</span>
<span class="kn">import</span> <span class="nn">db</span>
</pre></div>
</div>
<p>After all that, our file tree looks like this:</p>
<div class="highlight-python"><div class="highlight"><pre>.
├── __init__.py
├── db
│   ├── __init__.py
│   └── migrations.py
└── lb.py
</pre></div>
</div>
<p>and <tt class="docutils literal"><span class="pre">fab</span> <span class="pre">--list</span></tt> shows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">deploy</span>
<span class="n">compress</span>
<span class="n">lb</span><span class="o">.</span><span class="n">add_backend</span>
<span class="n">db</span><span class="o">.</span><span class="n">migrations</span><span class="o">.</span><span class="n">list</span>
<span class="n">db</span><span class="o">.</span><span class="n">migrations</span><span class="o">.</span><span class="n">run</span>
</pre></div>
</div>
<p>We could also have specified (or imported) tasks directly into
<tt class="docutils literal"><span class="pre">db/__init__.py</span></tt>, and they would show up as <tt class="docutils literal"><span class="pre">db.&lt;whatever&gt;</span></tt> as you might
expect.</p>
</div>
<div class="section" id="limiting-with-all">
<h4>Limiting with <tt class="docutils literal"><span class="pre">__all__</span></tt><a class="headerlink" href="#limiting-with-all" title="Permalink to this headline">¶</a></h4>
<p>You may limit what Fabric &#8220;sees&#8221; when it examines imported modules, by using
the Python convention of a module level <tt class="docutils literal"><span class="pre">__all__</span></tt> variable (a list of
variable names.) If we didn&#8217;t want the <tt class="docutils literal"><span class="pre">db.migrations.run</span></tt> task to show up by
default for some reason, we could add this to the top of <tt class="docutils literal"><span class="pre">db/migrations.py</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;list&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>Note the lack of <tt class="docutils literal"><span class="pre">'run'</span></tt> there. You could, if needed, import <tt class="docutils literal"><span class="pre">run</span></tt> directly
into some other part of the hierarchy, but otherwise it&#8217;ll remain hidden.</p>
</div>
<div class="section" id="switching-it-up">
<h4>Switching it up<a class="headerlink" href="#switching-it-up" title="Permalink to this headline">¶</a></h4>
<p>We&#8217;ve been keeping our fabfile package neatly organized and importing it in a
straightforward manner, but the filesystem layout doesn&#8217;t actually matter here.
All Fabric&#8217;s loader cares about is the names the modules are given when they&#8217;re
imported.</p>
<p>For example, if we changed the top of our root <tt class="docutils literal"><span class="pre">__init__.py</span></tt> to look like
this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">db</span> <span class="kn">as</span> <span class="nn">database</span>
</pre></div>
</div>
<p>Our task list would change thusly:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">deploy</span>
<span class="n">compress</span>
<span class="n">lb</span><span class="o">.</span><span class="n">add_backend</span>
<span class="n">database</span><span class="o">.</span><span class="n">migrations</span><span class="o">.</span><span class="n">list</span>
<span class="n">database</span><span class="o">.</span><span class="n">migrations</span><span class="o">.</span><span class="n">run</span>
</pre></div>
</div>
<p>This applies to any other import &#8211; you could import third party modules into
your own task hierarchy, or grab a deeply nested module and make it appear near
the top level.</p>
</div>
<div class="section" id="nested-list-output">
<h4>Nested list output<a class="headerlink" href="#nested-list-output" title="Permalink to this headline">¶</a></h4>
<p>As a final note, we&#8217;ve been using the default Fabric <a class="reference internal" href="fab.html#cmdoption-l"><em class="xref std std-option">--list</em></a>
output during this section &#8211; it makes it more obvious what the actual task
names are. However, you can get a more nested or tree-like view by passing
<tt class="docutils literal"><span class="pre">nested</span></tt> to the <a class="reference internal" href="fab.html#cmdoption-F"><em class="xref std std-option">--list-format</em></a> option:</p>
<div class="highlight-python"><div class="highlight"><pre>$ fab --list-format=nested --list
Available commands (remember to call as module.[...].task):

    deploy
    compress
    lb:
        add_backend
    database:
        migrations:
            list
            run
</pre></div>
</div>
<p>While it slightly obfuscates the &#8220;real&#8221; task names, this view provides a handy
way of noting the organization of tasks in large namespaces.</p>
</div>
</div>
</div>
<div class="section" id="classic-tasks">
<span id="id5"></span><h2>Classic tasks<a class="headerlink" href="#classic-tasks" title="Permalink to this headline">¶</a></h2>
<p>When no new-style <cite>~fabric.tasks.Task</cite>-based tasks are found, Fabric will
consider any callable object found in your fabfile, <strong>except</strong> the following:</p>
<ul class="simple">
<li>Callables whose name starts with an underscore (<tt class="docutils literal"><span class="pre">_</span></tt>). In other words,
Python&#8217;s usual &#8220;private&#8221; convention holds true here.</li>
<li>Callables defined within Fabric itself. Fabric&#8217;s own functions such as
<cite>~fabric.operations.run</cite> and <cite>~fabric.operations.sudo</cite>  will not show up in
your task list.</li>
</ul>
<div class="section" id="imports">
<h3>Imports<a class="headerlink" href="#imports" title="Permalink to this headline">¶</a></h3>
<p>Python&#8217;s <tt class="docutils literal"><span class="pre">import</span></tt> statement effectively includes the imported objects in your
module&#8217;s namespace. Since Fabric&#8217;s fabfiles are just Python modules, this means
that imports are also considered as possible classic-style tasks, alongside
anything defined in the fabfile itself.</p>
<blockquote>
<div><div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This only applies to imported <em>callable objects</em> &#8211; not modules.
Imported modules only come into play if they contain <a class="reference internal" href="#new-style-tasks"><em>new-style
tasks</em></a>, at which point this section no longer
applies.</p>
</div>
</div></blockquote>
<p>Because of this, we strongly recommend that you use the <tt class="docutils literal"><span class="pre">import</span> <span class="pre">module</span></tt> form
of importing, followed by <tt class="docutils literal"><span class="pre">module.callable()</span></tt>, which will result in a cleaner
fabfile API than doing <tt class="docutils literal"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">callable</span></tt>.</p>
<p>For example, here&#8217;s a sample fabfile which uses <tt class="docutils literal"><span class="pre">urllib.urlopen</span></tt> to get some
data out of a webservice:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">urllib</span> <span class="kn">import</span> <span class="n">urlopen</span>

<span class="kn">from</span> <span class="nn">fabric.api</span> <span class="kn">import</span> <span class="n">run</span>

<span class="k">def</span> <span class="nf">webservice_read</span><span class="p">():</span>
    <span class="n">objects</span> <span class="o">=</span> <span class="n">urlopen</span><span class="p">(</span><span class="s">&#39;http://my/web/service/?foo=bar&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="n">objects</span><span class="p">)</span>
</pre></div>
</div>
<p>This looks simple enough, and will run without error. However, look what
happens if we run <a class="reference internal" href="fab.html#cmdoption-l"><em class="xref std std-option">fab --list</em></a> on this fabfile:</p>
<div class="highlight-python"><div class="highlight"><pre>$ fab --list
Available commands:

  webservice_read   List some directories.
  urlopen           urlopen(url [, data]) -&gt; open file-like object
</pre></div>
</div>
<p>Our fabfile of only one task is showing two &#8220;tasks&#8221;, which is bad enough, and
an unsuspecting user might accidentally try to call <tt class="docutils literal"><span class="pre">fab</span> <span class="pre">urlopen</span></tt>, which
probably won&#8217;t work very well. Imagine any real-world fabfile, which is likely
to be much more complex, and hopefully you can see how this could get messy
fast.</p>
<p>For reference, here&#8217;s the recommended way to do it:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">urllib</span>

<span class="kn">from</span> <span class="nn">fabric.api</span> <span class="kn">import</span> <span class="n">run</span>

<span class="k">def</span> <span class="nf">webservice_read</span><span class="p">():</span>
    <span class="n">objects</span> <span class="o">=</span> <span class="n">urllib</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="s">&#39;http://my/web/service/?foo=bar&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="n">objects</span><span class="p">)</span>
</pre></div>
</div>
<p>It&#8217;s a simple change, but it&#8217;ll make anyone using your fabfile a bit happier.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Defining tasks</a><ul>
<li><a class="reference internal" href="#new-style-tasks">New-style tasks</a><ul>
<li><a class="reference internal" href="#the-task-decorator">The <tt class="docutils literal"><span class="pre">&#64;task</span></tt> decorator</a><ul>
<li><a class="reference internal" href="#arguments">Arguments</a></li>
<li><a class="reference internal" href="#aliases">Aliases</a></li>
<li><a class="reference internal" href="#default-tasks">Default tasks</a></li>
<li><a class="reference internal" href="#top-level-default-tasks">Top-level default tasks</a></li>
</ul>
</li>
<li><a class="reference internal" href="#task-subclasses"><tt class="docutils literal"><span class="pre">Task</span></tt> subclasses</a><ul>
<li><a class="reference internal" href="#using-custom-subclasses-with-task">Using custom subclasses with <tt class="docutils literal"><span class="pre">&#64;task</span></tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#namespaces">Namespaces</a><ul>
<li><a class="reference internal" href="#basic">Basic</a></li>
<li><a class="reference internal" href="#importing-a-submodule">Importing a submodule</a></li>
<li><a class="reference internal" href="#going-deeper">Going deeper</a></li>
<li><a class="reference internal" href="#limiting-with-all">Limiting with <tt class="docutils literal"><span class="pre">__all__</span></tt></a></li>
<li><a class="reference internal" href="#switching-it-up">Switching it up</a></li>
<li><a class="reference internal" href="#nested-list-output">Nested list output</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#classic-tasks">Classic tasks</a><ul>
<li><a class="reference internal" href="#imports">Imports</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="ssh.html"
                        title="previous chapter">SSH behavior</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="../api/contrib/console.html"
                        title="next chapter">Console Output Utilities</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/usage/tasks.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../api/contrib/console.html" title="Console Output Utilities"
             >next</a> |</li>
        <li class="right" >
          <a href="ssh.html" title="SSH behavior"
             >previous</a> |</li>
        <li><a href="../index.html">Fabric-docs-cn 1.8 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, Felix.Lu.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>